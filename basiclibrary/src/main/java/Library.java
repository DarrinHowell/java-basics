import java.util.*;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class Library {

    // uses a random number generator to simulate rolling a die.
    // returns an array of n length with all of the rolls recorded inside.
    public static int[] roll(int n) {
        int[] resultsArr = new int[n];

        for(int i = 0; i < resultsArr.length; i++){
            int randomRoll = (int)(Math.random() * 6 + 1);
            resultsArr[i] = randomRoll;
        }

        return resultsArr;
    }

    // returns true if arr has duplicates, false if there are no duplicates
    public static boolean containsDuplicates(int[] arr) {

        for(int i = 0; i < arr.length-1; i++){
            for(int j = i + 1; j < arr.length; j++){
                if(arr[i] == arr[j]){
                    return true;
                }
            }
        }

        return false;
    }

    // finds the average of a an array of ints
    public static double averageFinder(int[] arr){

        int sum = 0;

        for(int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }

        double avg = (double) sum / arr.length;

        return avg;
    }

    // returns the int array with the smallest average within an array of arrays
    public static int[] arrayOfArrays(int[][] arrOfArrs){

        int lowIdx = 0;
        for(int i = 1; i < arrOfArrs.length; i++){
            if(averageFinder(arrOfArrs[i]) < averageFinder(arrOfArrs[lowIdx])){
                lowIdx = i;
            }
        }
        return arrOfArrs[lowIdx];
    }

    // method analyzes weather data and returns the high, low, and temperatures
    // that weren't seen between the high and low during the month.
    public static void analyzeWeather(int[][] arrOfArr){

        // initialize HashSet
        HashSet<Integer> uniqueTemps = new HashSet<>();


        int max = -460; // absolute zero kelvin in F
        int min = arrOfArr[0][0];
        uniqueTemps.add(arrOfArr[0][0]);

        // find min, max, and unique values
        for(int[] weatherData: arrOfArr){
            for(int i = 0; i < weatherData.length; i++){

                // if it's not in the hash set, add it
                if(!uniqueTemps.contains(weatherData[i])){
                    uniqueTemps.add(weatherData[i]);
                }

                // find max
                if(weatherData[i] > max){
                    max = weatherData[i];
                }

                // find min
                if(weatherData[i] < min){
                    min = weatherData[i];
                }
            }
        }

        System.out.println("High: " + max);

        System.out.println();

        System.out.println("Low: " + min);

        System.out.println();

        // find missing values
        ArrayList<Integer> missingVals = new ArrayList<>();
        for(int i = min; i < max; i++){
            if(!uniqueTemps.contains(i)){
                missingVals.add(i);
                System.out.println("Never saw temperature " + i);
                System.out.println();
            }
        }
    }


    public static String tally(List<String> votes){

        HashMap<String,Integer> namesAndVotes = new HashMap<>();


        // tally votes
        for(String candidate : votes ){
            // if name is not in hashmap add it
            if(namesAndVotes.isEmpty()) {
                namesAndVotes.put(candidate, 1);
            }

            if(!namesAndVotes.containsKey(candidate)){
                namesAndVotes.put(candidate, 1);

            // if name is already there and we grab it again, add 1 to numVotes
            } else if(namesAndVotes.containsKey(candidate)){
                namesAndVotes.put(candidate, namesAndVotes.get(candidate) + 1);
            }

        }

        int numCandidates = namesAndVotes.size();

        // find the winner
        int mostVotes = 0;
        String winningTheRace = "";
        Set<String> candidates = namesAndVotes.keySet();

        for(String candidate: candidates){
            if(namesAndVotes.get(candidate) > mostVotes){
                mostVotes = namesAndVotes.get(candidate);
                winningTheRace = candidate;
            }
        }

        return winningTheRace;

    }

}
